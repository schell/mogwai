#[macro_use]
extern crate log;
extern crate console_log;
extern crate web_sys;
extern crate mogwai_design;

use log::Level;
use std::cell::RefCell;
use std::rc::Rc;
use wasm_bindgen::JsCast;
use wasm_bindgen::prelude::*;
use web_sys::{Element, Event, Document, HtmlElement, Node, Text, window};
//use std::thread::sleep;
//use std::time::Duration;

use mogwai_design::prelude::*;


/// Creates a button that changes its text every time it is clicked.
/// The button will also transmit clicks into the given transmitter.
pub fn new_button_gizmo(tx_click: Transmitter<Event>) -> Result<Gizmo, JsValue> {
  // Branch from the given input for a new wire which feeds into a new
  // receiver.
  let (mut click_to_text, rx_text) =
    Wire::<Event, bool, String>::branch(tx_click, false);

  // Create the button that gets its text from our receiver.
  //
  // The button text will start out as "Click me" and then change to whatever
  // comes in on the receiver.
  let mut button =
    button()
    .named("button")
    .rx_text("Click me", rx_text)
    .build()?;

  // Have the button transmit on tx_click
  button.tx_on("click", tx_click);

  // Now that the routing is done, we can define how the signal changes from
  // transmitter to receiver over each occurance.

  click_to_text
    .on_input(|is_red, _| {
      trace!("click_to_text::on_input");
      trace!("  last is_red:{}", is_red);
      let out =
        if is_red {
          "Turn me blue".into()
        } else {
          "Turn me red".into()
        };
      trace!("  out:{:?}", out);
      (!is_red, Some(out))
    });

  button.bundle(btn_click_to_btn_text);
  button
}


#[wasm_bindgen]
pub fn main() -> Result<(), JsValue> {
  console_log::init_with_level(Level::Trace)
    .unwrap();
  trace!("Hello from mogwai");

  let app:Gizmo = {
    // Create a transmitter to send messages with.
    let tx_btn_click:Transmitter<()> = Transmitter::new();

    let (tx_btn_click, mut btn_click_to_h1_color, rx_h1_color) =
      Wire::<Event, bool, String>::hookups(false);

    // Create a gizmo for our heading
    let h1:Gizmo =
      h1()
      .named("h1")
      .attribute("id", "header")
      .attribute("class", "my-header")
      // Pass the receiving end into the gizmo along with an initial value
      .style_rx("color", "green", rx_h1_color)
      .text("Hello from mogwai!")
      .build()?;

    // Now that the routing is done, let's define the logic

    // The h1's color will change every click back and forth between blue and red
    // after the initial green.
    btn_click_to_h1_color
      .on_input(|is_red, _| {
        println!("btn_click_to_h1_color");
        let out =
          if is_red {
            "blue".into()
          } else {
            "red".into()
          };
        (!is_red, Some(out))
      });

    // Bundle all the wires together into a fusebox.
    let fusebox =
      FuseBox::new()
      .with(btn_click_to_btn_text)
      .with(btn_click_to_h1_color);

    // Put it all in a div gizmo
    let mut div =
      div()
      .named("root_div")
      .with(h1)
      .with(button)
      .build()?;

    div.fuse_box = fusebox;
    div
  };

  trace!("Done building...");

  app.run()
}
